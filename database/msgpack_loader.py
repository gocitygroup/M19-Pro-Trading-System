"""
Utility module for loading trading symbols from msgpack files.
This module provides functions to read and extract symbol information
from the mt5_symbols.msgpack file generated by mt5_symbol_retriever.py
"""

import msgpack
import os
from pathlib import Path
from typing import List, Tuple, Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)


def get_default_msgpack_path() -> str:
    """
    Get the default path to mt5_symbols.msgpack in the database directory.
    
    Returns:
        Absolute path to mt5_symbols.msgpack
    """
    # Get the directory where this module is located (database directory)
    database_dir = Path(__file__).parent.resolve()
    return str(database_dir / "mt5_symbols.msgpack")


class SymbolLoader:
    """Loader for trading symbols from msgpack files."""
    
    def __init__(self, msgpack_file: Optional[str] = None):
        """
        Initialize the SymbolLoader.
        
        Args:
            msgpack_file: Path to the msgpack file containing symbol data.
                         If None, defaults to mt5_symbols.msgpack in the database directory.
        """
        if msgpack_file is None:
            msgpack_file = get_default_msgpack_path()
        self.msgpack_file = msgpack_file
        self._data = None
    
    def load_data(self) -> Optional[Dict[str, Any]]:
        """
        Load data from msgpack file.
        
        Returns:
            Dictionary containing symbol data or None if file doesn't exist
        """
        if not os.path.exists(self.msgpack_file):
            logger.warning(f"Msgpack file not found: {self.msgpack_file}")
            return None
        
        try:
            with open(self.msgpack_file, 'rb') as f:
                self._data = msgpack.unpack(f, raw=False)
            
            logger.info(f"Loaded {self._data['metadata']['total_symbols']} symbols from {self.msgpack_file}")
            return self._data
            
        except Exception as e:
            logger.error(f"Error loading msgpack file: {str(e)}")
            return None
    
    def _map_category_to_db_format(self, category: str) -> str:
        """
        Map internal category format to database format.
        
        Args:
            category: Internal category ('most_traded', 'metals', 'crypto', 'other', 'commodities')
        
        Returns:
            Database-compatible category ('mostTraded', 'metals', 'crypto', 'other')
        """
        category_mapping = {
            'most_traded': 'mostTraded',
            'metals': 'metals',
            'crypto': 'crypto',
            'other': 'other',
            'commodities': 'other'  # Map commodities to 'other' for database compatibility
        }
        return category_mapping.get(category, 'other')
    
    def get_all_symbols(self, db_format: bool = False) -> List[Tuple[str, str]]:
        """
        Get all symbols with their categories.
        
        Args:
            db_format: If True, returns categories in database format (mostTraded instead of most_traded)
        
        Returns:
            List of tuples (symbol, category) where category is one of:
            'most_traded'/'mostTraded', 'metals', 'crypto', 'other'
        """
        if self._data is None:
            self.load_data()
        
        if self._data is None:
            logger.warning("No data loaded, returning empty list")
            return []
        
        symbols = []
        
        # Extract symbols from the categorized structure
        symbol_data = self._data.get('symbols', {})
        
        # Process Forex symbols (most_traded)
        # But filter out crypto tokens that were miscategorized as forex
        forex_data = symbol_data.get('Forex', {})
        
        # Known crypto token patterns (tokens that end with USD but are actually crypto)
        crypto_tokens = {
            'AAVE', 'ALGO', 'ATOM', 'AVAX', 'AVX', 'AXS', 'BAT', 'BCH', 'BNB', 'BTC', 'COMP',
            'CRV', 'DASH', 'DOGE', 'DOT', 'EOS', 'ETC', 'ETH', 'FIL', 'FLOW', 'FTM',
            'GRT', 'ICP', 'LINK', 'LTC', 'MANA', 'MATIC', 'MKR', 'NEAR', 'OP', 'SAND',
            'SHIB', 'SNX', 'SOL', 'SUSHI', 'UNI', 'XLM', 'XMR', 'XRP', 'XTZ', 'YFI',
            'ZEC', 'AERO', 'APT', 'ARB', 'ASTER', 'FET', 'INJ', 'PEPE', 'BONK', 'FLOKI',
            'INCH', 'BLUR', 'PENDLE', 'RUNE', 'GALA', 'CHZ', 'ENJ', 'THETA', 'CAKE', 'STORJ'
        }
        
        for subcategory, symbol_list in forex_data.items():
            for symbol_info in symbol_list:
                symbol_name = symbol_info['name']
                
                # Check if this is actually a crypto token
                is_crypto = False
                for token in crypto_tokens:
                    if symbol_name.startswith(token) and symbol_name.endswith('USD'):
                        is_crypto = True
                        break
                    # Handle tokens like 1000xSHIB
                    if token in symbol_name and 'USD' in symbol_name:
                        is_crypto = True
                        break
                
                if is_crypto:
                    category = 'crypto'
                else:
                    category = 'most_traded'
                
                if db_format:
                    category = self._map_category_to_db_format(category)
                
                symbols.append((symbol_name, category))
        
        # Process Commodities
        # Separate metals from other commodities
        commodity_data = symbol_data.get('Commodities', {})
        metal_prefixes = {'XAU', 'XAG', 'XPT', 'XPD', 'GOLD', 'SILVER', 'PLATINUM', 'PALLADIUM'}
        
        for subcategory, symbol_list in commodity_data.items():
            for symbol_info in symbol_list:
                symbol_name = symbol_info['name']
                
                # Check if this is a precious metal (even if not in Metals subcategory)
                is_metal = any(symbol_name.startswith(prefix) for prefix in metal_prefixes)
                
                # Map Metals subcategory or metal symbols to 'metals'
                if subcategory == 'Metals' or is_metal:
                    category = 'metals'
                else:
                    # Energies and Other commodities go to 'commodities' category
                    category = 'commodities'
                
                if db_format:
                    category = self._map_category_to_db_format(category)
                
                symbols.append((symbol_name, category))
        
        # Process Crypto
        # Filter out forex pairs and metals that were miscategorized as crypto
        crypto_data = symbol_data.get('Crypto', {})
        forex_currency_codes = {'USD', 'EUR', 'GBP', 'JPY', 'CHF', 'CAD', 'AUD', 'NZD', 
                               'CNH', 'CZK', 'DKK', 'HKD', 'HUF', 'MXN', 'NOK', 'PLN', 
                               'RUB', 'SEK', 'SGD', 'THB', 'TRY', 'ZAR'}
        metal_prefixes = {'XAU', 'XAG', 'XPT', 'XPD', 'GOLD', 'SILVER', 'PLATINUM', 'PALLADIUM'}
        
        for subcategory, symbol_list in crypto_data.items():
            for symbol_info in symbol_list:
                symbol_name = symbol_info['name']
                
                # Check if this is actually a metal
                is_metal = any(symbol_name.startswith(prefix) for prefix in metal_prefixes)
                
                # Check if this is actually a forex pair miscategorized as crypto
                # Forex pairs typically have 6-8 letter names with currency codes
                is_forex_pair = False
                if not is_metal and len(symbol_name) >= 6 and symbol_name.isalpha():
                    # Check if it contains known forex currency codes
                    for i in range(3, 5):
                        if i <= len(symbol_name) - 3:
                            base = symbol_name[:i]
                            quote = symbol_name[i:i+3] if i+3 <= len(symbol_name) else symbol_name[i:]
                            if base in forex_currency_codes and quote in forex_currency_codes:
                                is_forex_pair = True
                                break
                
                # Categorize appropriately
                if is_metal:
                    category = 'metals'
                elif is_forex_pair:
                    category = 'most_traded'
                else:
                    category = 'crypto'
                
                if db_format:
                    category = self._map_category_to_db_format(category)
                
                symbols.append((symbol_name, category))
        
        # Process Other
        other_data = symbol_data.get('Other', {})
        for subcategory, symbol_list in other_data.items():
            for symbol_info in symbol_list:
                symbol_name = symbol_info['name']
                category = 'other'
                if db_format:
                    category = self._map_category_to_db_format(category)
                symbols.append((symbol_name, category))
        
        # Log category distribution
        category_counts = {}
        for _, category in symbols:
            category_counts[category] = category_counts.get(category, 0) + 1
        
        logger.info(f"Extracted {len(symbols)} symbols from msgpack data")
        for category, count in sorted(category_counts.items()):
            logger.info(f"  {category}: {count}")
        
        return symbols
    
    def get_symbols_by_category(self, category: str) -> List[str]:
        """
        Get all symbols of a specific category.
        
        Args:
            category: Category name ('Forex', 'Commodities', 'Crypto', 'Other')
        
        Returns:
            List of symbol names
        """
        if self._data is None:
            self.load_data()
        
        if self._data is None:
            return []
        
        symbols = []
        symbol_data = self._data.get('symbols', {})
        category_data = symbol_data.get(category, {})
        
        for subcategory, symbol_list in category_data.items():
            for symbol_info in symbol_list:
                symbols.append(symbol_info['name'])
        
        return symbols
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get statistics about the loaded symbols.
        
        Returns:
            Dictionary containing statistics
        """
        if self._data is None:
            self.load_data()
        
        if self._data is None:
            return {}
        
        return self._data.get('metadata', {}).get('statistics', {})
    
    def print_summary(self):
        """Print a summary of loaded symbols."""
        if self._data is None:
            self.load_data()
        
        if self._data is None:
            print("No data loaded")
            return
        
        metadata = self._data.get('metadata', {})
        stats = metadata.get('statistics', {})
        total = metadata.get('total_symbols', 0)
        
        print(f"\n=== Symbol Summary ===")
        print(f"Total symbols: {total}")
        print(f"\nBreakdown by category:")
        
        for category, subcategories in stats.items():
            print(f"\n{category}:")
            for subcategory, count in subcategories.items():
                print(f"  {subcategory}: {count}")


def load_symbols_from_msgpack(msgpack_file: Optional[str] = None, db_format: bool = False) -> List[Tuple[str, str]]:
    """
    Convenience function to load symbols from msgpack file.
    
    Args:
        msgpack_file: Path to msgpack file. If None, defaults to mt5_symbols.msgpack in database directory.
        db_format: If True, returns categories in database format (mostTraded instead of most_traded)
    
    Returns:
        List of tuples (symbol, category)
    """
    loader = SymbolLoader(msgpack_file)
    return loader.get_all_symbols(db_format=db_format)


def get_fallback_symbols() -> List[Tuple[str, str]]:
    """
    Get fallback symbol list in case msgpack file is not available.
    This returns a basic set of commonly traded symbols.
    
    Returns:
        List of tuples (symbol, category)
    """
    logger.warning("Using fallback symbol list")
    return [
        # Most traded currency pairs (Forex)
        ('EURUSD', 'most_traded'), ('USDJPY', 'most_traded'), ('GBPUSD', 'most_traded'), 
        ('AUDUSD', 'most_traded'), ('USDCAD', 'most_traded'), ('USDCHF', 'most_traded'),
        ('NZDUSD', 'most_traded'), ('EURJPY', 'most_traded'), ('GBPJPY', 'most_traded'), 
        ('EURGBP', 'most_traded'), ('AUDJPY', 'most_traded'), ('EURCHF', 'most_traded'),
        ('EURCAD', 'most_traded'), ('EURAUD', 'most_traded'), ('AUDNZD', 'most_traded'), 
        ('AUDCAD', 'most_traded'), ('AUDCHF', 'most_traded'), ('CHFJPY', 'most_traded'),
        ('EURNZD', 'most_traded'), ('GBPCHF', 'most_traded'), ('CADCHF', 'most_traded'), 
        ('GBPCAD', 'most_traded'), ('CADJPY', 'most_traded'),
        # Precious Metals
        ('XAUUSD', 'metals'), ('XAGUSD', 'metals'), ('XAUEUR', 'metals'),
        # Commodities (Energy)
        ('XTIUSD', 'commodities'), ('XBRUSD', 'commodities'),
        # Cryptocurrencies
        ('BTCUSD', 'crypto'), ('ETHUSD', 'crypto'), ('LTCUSD', 'crypto'),
    ]


if __name__ == "__main__":
    # Test the loader
    loader = SymbolLoader()
    loader.print_summary()
    
    symbols = loader.get_all_symbols()
    print(f"\nFirst 10 symbols:")
    for symbol, category in symbols[:10]:
        print(f"  {symbol}: {category}")

